package analysis

import (
	"numberniceic/internal/core/domain"
	"fmt"
	"encoding/json"
	"encoding/base64"
	"strings"
)


type SolarSystemProps struct {
	CleanedName          string                        `json:"cleaned_name"`
	InputDay             string                        `json:"input_day"`
	InputDayRaw          string                        `json:"input_day_raw"`
	DisableKlakini       bool                          `json:"disable_klakini"`
	IsVIP                bool                          `json:"is_vip"`
	SunDisplayNameHTML   []domain.DisplayChar          `json:"sun_display_name_html"`
	NumerologyPairs      []domain.PairMeaningResult    `json:"numerology_pairs"`
	ShadowPairs          []domain.PairMeaningResult    `json:"shadow_pairs"`
	NumPositiveScore     int                           `json:"num_positive_score"`
	NumNegativeScore     int                           `json:"num_negative_score"`
	ShaPositiveScore     int                           `json:"sha_positive_score"`
	ShaNegativeScore     int                           `json:"sha_negative_score"`
	GrandTotalScore      int                           `json:"grand_total_score"`
	IsSunDead            bool                          `json:"is_sun_dead"`
	AllUniquePairs       []domain.PairMeaningResult    `json:"all_unique_pairs"`
	DecodedParts         []domain.DecodedResult        `json:"decoded_parts"`
	TotalNumerologyValue int                           `json:"total_numerology_value"`
	TotalShadowValue     int                           `json:"total_shadow_value"`
	SkipTrigger          bool                          `json:"skip_trigger"`
	CategoryCounts       map[string]int                `json:"category_counts"`
	CategoryBreakdown    map[string]domain.CategoryBreakdown  `json:"category_breakdown"`
}

func (p SolarSystemProps) GetCategoryDataJSON() string {
	b, _ := json.Marshal(p.CategoryCounts)
	return base64.StdEncoding.EncodeToString(b)
}

func (p SolarSystemProps) GetCategoryBreakdownJSON() string {
	b, _ := json.Marshal(p.CategoryBreakdown)
	return base64.StdEncoding.EncodeToString(b)
}

func (p SolarSystemProps) GetLinguisticTotalScore() float64 {
	totalGood := 0
	totalBad := 0
	for _, cat := range []string{"‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û", "‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô", "‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô", "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å"} {
		if breakdown, ok := p.CategoryBreakdown[cat]; ok {
			totalGood += breakdown.Good
			totalBad += breakdown.Bad
		}
	}
	totalPairs := float64(len(p.NumerologyPairs) + len(p.ShadowPairs))
	if totalPairs == 0 { return 0 }
	return (float64(totalGood - totalBad) / totalPairs) * 100
}

func (p SolarSystemProps) GetLinguisticScoreColor() string {
	score := p.GetLinguisticTotalScore()
	if score < 0 { return "#C62828" }
	return "#2E7D32"
}

func getCategoryColor(cat string) string {
	switch cat {
	case "‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô": return "#4158D0"
	case "‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û": return "#00DBDE"
	case "‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô": return "#FB8C00"
	case "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å": return "#D4145A"
	default: return "#A0A0A0"
	}
}












script DrawNestedDonut(id string, data string) {
	(function() {
		setTimeout(() => {
			try {
				console.log('[Nested Donut] Starting for ID:', id);
			
			const breakdown = JSON.parse(atob(data));
			console.log('[Nested Donut] Breakdown data:', breakdown);
			
			const svg = document.getElementById(id);
			if (!svg) {
				console.error('[Nested Donut] SVG not found:', id);
				return;
			}
			
			const innerRing = svg.querySelector('.inner-ring');
			const outerRing = svg.querySelector('.outer-ring');
			
			// Calculate totals
			let totalPairs = 0;
			const categories = [];
			for (const [cat, counts] of Object.entries(breakdown)) {
				const total = counts.good + counts.bad;
				totalPairs += total;
				// counts now includes 'color' field from Go
				categories.push({ name: cat, good: counts.good, bad: counts.bad, color: counts.color, total });
			}
			
			// If no pairs, show placeholder
			if (totalPairs === 0) {
				console.warn('[Nested Donut] No pairs to display');
				// Draw a gray circle as placeholder
				const placeholderPath = createArcPath(100, 100, 45, 18, -90, 270);
				const pathElem = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				pathElem.setAttribute('d', placeholderPath);
				pathElem.setAttribute('fill', '#E0E0E0');
				innerRing.appendChild(pathElem);
				
				// Still set legend colors even if no data
				categories.forEach(cat => {
					const legendBox = document.querySelector(`[data-category="${cat.name}"]`);
					if (legendBox) {
						legendBox.style.background = cat.color || '#A0A0A0';
					}
				});
				return;
			}
			
			// Set legend colors for ALL categories first
			categories.forEach(cat => {
				const legendBox = document.querySelector(`[data-category="${cat.name}"]`);
				if (legendBox) {
					legendBox.style.background = cat.color || '#A0A0A0';
				}
			});
			
			// Hide center text elements as they will be covered by the pie chart
			const centerNumber = svg.querySelector('.donut-center-number');
			const centerLabel = svg.querySelector('.donut-center-label');
			if (centerNumber) centerNumber.style.display = 'none';
			if (centerLabel) centerLabel.style.display = 'none';

			// Draw inner ring (categories) - PIE CHART Style
			let currentAngle = -45; // Start from -45 degrees for diagonal split
			const innerRadius = 0; // Pie chart starts from center
			const innerThickness = 50; // Radius of the pie
			
			categories.forEach((cat, index) => {
				if (cat.total === 0) return; // Skip categories with 0 total
				
				const percentage = cat.total / totalPairs;
				const angle = percentage * 360;
				// Use color from Go backend, fallback to gray
				const color = cat.color || '#A0A0A0';
				console.log('[Nested Donut] Cat:', cat.name, 'Color:', color);
				
				const path = createArcPath(100, 100, innerRadius, innerThickness, currentAngle, currentAngle + angle);
				const pathElem = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				pathElem.setAttribute('d', path);
				pathElem.setAttribute('fill', color);
				pathElem.setAttribute('class', 'donut-segment');
				pathElem.setAttribute('stroke', '#fff'); // Add white border
				pathElem.setAttribute('stroke-width', '1');
				
				// Fix Thai encoding issue by using textContent
				const titleElem = document.createElementNS('http://www.w3.org/2000/svg', 'title');
				titleElem.textContent = `${cat.name}: ${cat.total} ‡∏Ñ‡∏π‡πà`;
				pathElem.appendChild(titleElem);
				
				innerRing.appendChild(pathElem);

				// Add Percentage Label
				if (percentage > 0.05) { // Only show label if > 5%
					// Calculate position at 60% of radius (middle of the slice area roughly)
					const labelRadius = innerThickness * 0.6; 
					const midAngle = currentAngle + (angle / 2);
					const midRad = (midAngle * Math.PI) / 180;
					
					const tx = 100 + labelRadius * Math.cos(midRad);
					const ty = 100 + labelRadius * Math.sin(midRad);
					
					// Determine label color: Red if Bad > Good
					let labelColor = '#fff';
					let textShadow = '0px 1px 2px rgba(0,0,0,0.4)';
					
					// If Bad is significantly higher than Good (or just higher), alert with Red
					if (cat.bad > cat.good) {
						labelColor = '#ffeb3b'; // Use Yellow for better visibility on dark backgrounds? Or Red #ff3b30?
						// User asked for "Red", but Red on Red (Love) is bad.
						// Let's try explicit bright Red/Yellow hybrid or just Red with white stroke.
						labelColor = '#ff0000';
						textShadow = '0px 0px 3px #fff, 0px 0px 5px #fff'; // White glow to generate contrast
					}

					const textElem = document.createElementNS('http://www.w3.org/2000/svg', 'text');
					textElem.setAttribute('x', tx);
					textElem.setAttribute('y', ty);
					textElem.setAttribute('text-anchor', 'middle');
					textElem.setAttribute('dominant-baseline', 'middle');
					textElem.setAttribute('fill', labelColor);
					textElem.setAttribute('font-size', '11px');
					textElem.setAttribute('font-weight', 'bold');
					textElem.setAttribute('style', `pointer-events: none; text-shadow: ${textShadow};`);
					textElem.textContent = Math.round(percentage * 100) + '%';
					innerRing.appendChild(textElem);
				}
				
				// Update legend color
				const legendBox = document.querySelector(`[data-category="${cat.name}"]`);
				if (legendBox) legendBox.style.background = color;
				
				currentAngle += angle;
			});
			
			// Draw outer ring (good/bad for each category)
			currentAngle = -90;
			const outerRadius = 55; // Gap from pie (50 + 5 gap)
			const outerThickness = 15;
			
			categories.forEach(cat => {
				if (cat.total === 0) return; // Skip categories with 0 total
				
				const catPercentage = cat.total / totalPairs;
				const catAngle = catPercentage * 360;
				
				if (cat.good > 0) {
					const goodPercentage = cat.good / cat.total;
					const goodAngle = catAngle * goodPercentage;
					const path = createArcPath(100, 100, outerRadius, outerThickness, currentAngle, currentAngle + goodAngle);
					const pathElem = document.createElementNS('http://www.w3.org/2000/svg', 'path');
					pathElem.setAttribute('d', path);
					pathElem.setAttribute('fill', '#4CAF50');
					pathElem.setAttribute('class', 'donut-segment outer');
					pathElem.innerHTML = `<title>${cat.name} - ‡πÄ‡∏•‡∏Ç‡∏î‡∏µ: ${cat.good} ‡∏Ñ‡∏π‡πà</title>`;
					outerRing.appendChild(pathElem);
					currentAngle += goodAngle;
				}
				
				if (cat.bad > 0) {
					const badPercentage = cat.bad / cat.total;
					const badAngle = catAngle * badPercentage;
					const path = createArcPath(100, 100, outerRadius, outerThickness, currentAngle, currentAngle + badAngle);
					const pathElem = document.createElementNS('http://www.w3.org/2000/svg', 'path');
					pathElem.setAttribute('d', path);
					pathElem.setAttribute('fill', '#F44336');
					pathElem.setAttribute('class', 'donut-segment outer');
					pathElem.innerHTML = `<title>${cat.name} - ‡πÄ‡∏•‡∏Ç‡∏£‡πâ‡∏≤‡∏¢: ${cat.bad} ‡∏Ñ‡∏π‡πà</title>`;
					outerRing.appendChild(pathElem);
					currentAngle += badAngle;
				}
			});
			
			
			console.log('[Nested Donut] ‚úì Chart rendered successfully');

			
			// Helper function to create SVG arc path
			function createArcPath(cx, cy, radius, thickness, startAngle, endAngle) {
				// Handle full circle case
				if (endAngle - startAngle >= 359.9) {
					endAngle = startAngle + 359.99;
				}

				const innerRadius = radius;
				const outerRadius = radius + thickness;
				
				const startRad = (startAngle * Math.PI) / 180;
				const endRad = (endAngle * Math.PI) / 180;
				
				const x1 = cx + outerRadius * Math.cos(startRad);
				const y1 = cy + outerRadius * Math.sin(startRad);
				const x2 = cx + outerRadius * Math.cos(endRad);
				const y2 = cy + outerRadius * Math.sin(endRad);
				const x3 = cx + innerRadius * Math.cos(endRad);
				const y3 = cy + innerRadius * Math.sin(endRad);
				const x4 = cx + innerRadius * Math.cos(startRad);
				const y4 = cy + innerRadius * Math.sin(startRad);
				
				const largeArc = endAngle - startAngle > 180 ? 1 : 0;
				
				return `M ${x1} ${y1} A ${outerRadius} ${outerRadius} 0 ${largeArc} 1 ${x2} ${y2} L ${x3} ${y3} A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${x4} ${y4} Z`;
			}

		} catch (error) {
			console.error('[Nested Donut] Error:', error);
		}
		}, 0);
	})();
}

templ SolarSystem(props SolarSystemProps) {
	<style>
		@keyframes shimmer {
			0% { background-position: -200% 0; }
			100% { background-position: 200% 0; }
		}
		.sparkling-gold {
			background: linear-gradient(90deg, #FFD700, #FFF8DC, #FFD700, #DAA520, #FFD700);
			background-size: 200% auto;
			color: #8B4513 !important;
			border: 1px solid #DAA520 !important;
			font-weight: 800 !important;
			text-shadow: 0 0 2px rgba(255, 255, 255, 0.8);
			animation: shimmer 6s linear infinite;
			box-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
		}
		.sparkling-gold svg {
			filter: drop-shadow(0 0 1px rgba(139, 69, 19, 0.5));
		}
	</style>



	<div class="solar-dashboard-layout" style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 2rem; flex-wrap: wrap-reverse; margin-bottom: 2rem;">
		
		<!-- LEFT: Stats & Controls -->
		<div class="stats-control-panel fade-slide-in" style="display: flex; flex-direction: column; gap: 1rem; align-items: center;">
			
			<!-- Good / Bad Pills -->
			<div class="score-pills" style="display: flex; flex-direction: column; gap: 0.5rem; width: 100%;">
				<div class="score-badge-positive" style="justify-content: center; font-size: 1rem;">
					‡∏î‡∏µ 
					if (props.NumPositiveScore + props.ShaPositiveScore) > 0 {
						+{ fmt.Sprintf("%d", props.NumPositiveScore + props.ShaPositiveScore) }
					} else {
						{ fmt.Sprintf("%d", props.NumPositiveScore + props.ShaPositiveScore) }
					}
				</div>
				<div class="score-badge-negative" style="justify-content: center; font-size: 1rem;">
					‡∏£‡πâ‡∏≤‡∏¢ { fmt.Sprintf("%d", props.NumNegativeScore + props.ShaNegativeScore) }
				</div>
			</div>

			<!-- Total Score -->
			<div class="score-summary" style="flex-direction: column; gap: 0.2rem; margin-left: 0;">
				<div class="score-summary-label" style="font-size: 0.9rem;">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏£‡∏ß‡∏°</div>
				<div class={ "score-summary-value", 
					templ.KV("score-negative", props.GrandTotalScore < 0),
					templ.KV("score-positive", props.GrandTotalScore >= 0) } style="font-size: 2.2rem;">
					if props.GrandTotalScore > 0 {
						<span style="display: flex; align-items: center; gap: 8px;">
							<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#FFD700" stroke="#B8860B" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1));">
								<path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
								<path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
								<path d="M4 22h16"></path>
								<path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
								<path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
								<path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
							</svg>
							+{ fmt.Sprintf("%d", props.GrandTotalScore) }
						</span>
					} else {
						<span style="display: flex; align-items: center; gap: 8px;">
							<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#e0e0e0" stroke="#bdbdbd" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="filter: grayscale(1); opacity: 0.7;">
								<path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
								<path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
								<path d="M4 22h16"></path>
								<path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
								<path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
								<path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
							</svg>
							{ fmt.Sprintf("%d", props.GrandTotalScore) }
						</span>
					}
				</div>
			</div>

			<!-- Save Button -->
			<button type="button" hx-post="/saved-names"
				hx-vals={ fmt.Sprintf(`{"name": "%s", "birth_day": "%s", "total_score": "%d", "sat_sum": "%d", "sha_sum": "%d"}`, props.CleanedName, props.InputDayRaw, props.GrandTotalScore, props.TotalNumerologyValue, props.TotalShadowValue) }
				hx-swap="none"
				class="action-btn-premium btn-save"
				style="width: 100%; justify-content: center; padding: 0.6rem 1.2rem; font-size: 1rem;">
				<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
					<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
					<polyline points="17 21 17 13 7 13 7 21"></polyline>
					<polyline points="7 3 7 8 15 8"></polyline>
				</svg>
				<span class="btn-label">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</span>
			</button>

		</div>

		<!-- RIGHT: Solar System Chart -->
		<div class="solar-system-container fade-slide-in" style="flex: 0 0 auto;">
			<div class="solar-system">
				<div class={ "sun", templ.KV("sun-dead", props.IsSunDead) }>
					<div class="sun-name">
						<div class="char-container sun-name-container">
							if len(props.SunDisplayNameHTML) > 0 {
								<div class="sun-name-wrapper">
								for _, dc := range props.SunDisplayNameHTML {
									if dc.IsBad {
										<span class="klakini-char">{ dc.Char }</span>
									} else {
										{ dc.Char }
									}
								}
								</div>
							} else {
								<span>?</span>
							}
						</div>
					</div>
				</div>

				<!-- Orbits -->
				<div class="orbit orbit-inner"></div>
				<div class="orbit orbit-outer"></div>

				<!-- Planets (Numerology) -->
				if len(props.NumerologyPairs) > 0 {
					for i, pair := range props.NumerologyPairs {
						<div class="planet-container orbit-inner" style={ fmt.Sprintf("animation-delay: -%.2fs;", mul(float64(i), div(20.0, float64(len(props.NumerologyPairs))))) }>
							<div class="planet"
								style={ fmt.Sprintf("background-color: %s; animation-delay: -%.2fs;", pair.Meaning.Color, mul(float64(i), div(20.0, float64(len(props.NumerologyPairs))))) }
								title={ pair.Meaning.MiracleDesc }>
								{ pair.PairNumber }
							</div>
						</div>
					}
				}

				<!-- Planets (Shadow) -->
				if len(props.ShadowPairs) > 0 {
					for i, pair := range props.ShadowPairs {
						<div class="planet-container orbit-outer" style={ fmt.Sprintf("animation-delay: -%.2fs;", mul(float64(i), div(30.0, float64(len(props.ShadowPairs))))) }>
							<div class="planet"
								style={ fmt.Sprintf("background-color: %s; animation-delay: -%.2fs;", pair.Meaning.Color, mul(float64(i), div(30.0, float64(len(props.ShadowPairs))))) }
								title={ pair.Meaning.MiracleDesc }>
								{ pair.PairNumber }
							</div>
						</div>
					}
				}
			</div>
		</div>

	</div>

	<!-- Compact Result Card (Empty container for structure if needed, or removed) -->
	<div class="result-box-premium fade-slide-in" style="box-shadow: none; background: transparent; padding: 0;">


		<!-- Action Buttons -->
		<div class="action-buttons-container">
			<!-- Numerology Button -->
			<button type="button" { templ.Attributes{"onclick": fmt.Sprintf("openMeaningModal('%s')", props.CleanedName)}... }
				class="action-btn-premium btn-numerology">
				<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
					<rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
					<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
					<path d="M12 11h4"></path>
					<path d="M12 16h4"></path>
					<path d="M8 11h.01"></path>
					<path d="M8 16h.01"></path>
				</svg>
				<span class="btn-label-text">‡πÄ‡∏•‡∏Ç‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå</span>
			</button>

			<!-- Linguistic Button -->
			<!-- Linguistic Button -->
			<button type="button" 
				{ templ.Attributes{"onclick": fmt.Sprintf("loadLinguisticAnalysis('%s')", props.CleanedName)}... }
				class="action-btn-premium btn-linguistic">
				<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
					stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
					<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
					<path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
				</svg>
				<span class="btn-label-text">‡∏†‡∏≤‡∏©‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå</span>
			</button>
		</div>


		<!-- Category Chart Section - Nested Donut (Categories + Good/Bad) -->
		if len(props.CategoryBreakdown) > 0 {
			<div class="category-breakdown-container fade-slide-in">

				<div class="nested-donut-layout" style="display: flex; flex-direction: row; gap: 1.5rem; align-items: center; justify-content: center; flex-wrap: wrap;">
					<div class="nested-donut-wrapper">
						<svg class="nested-donut-chart" viewBox="0 0 200 200" id={ "nested-donut-" + props.CleanedName } style="width: 200px; height: 200px;">
							<!-- Inner ring (categories) will be drawn by JS -->
							<g class="inner-ring"></g>
							<!-- Outer ring (good/bad) will be drawn by JS -->

							<!-- Center text -->
							<text x="100" y="95" text-anchor="middle" class="donut-center-number">
								{ fmt.Sprintf("%d", len(props.NumerologyPairs) + len(props.ShadowPairs)) }
							</text>
							<text x="100" y="110" text-anchor="middle" class="donut-center-label">‡∏Ñ‡∏π‡πà‡πÄ‡∏•‡∏Ç</text>
						</svg>
					</div>
					<div class="nested-legend" style="min-width: 250px;">
						<div class="breakdown-summary" style="margin-top: 0.5rem;">
							<table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
								<thead>
									<tr style="border-bottom: 2px solid #f0f0f0;">
										<th style="text-align: left; padding: 8px; color: #555;">‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà</th>
										<th style="text-align: right; padding: 8px; color: #333; width: 60px;">%‡∏î‡∏µ</th>
										<th style="text-align: right; padding: 8px; color: #333; width: 60px;">%‡∏£‡πâ‡∏≤‡∏¢</th>
										<th style="text-align: center; padding: 8px; color: #333; width: 80px;">‡πÄ‡∏™‡∏£‡∏¥‡∏°‡πÄ‡∏ö‡∏≠‡∏£‡πå</th>
									</tr>
								</thead>
								<tbody>
									for i, cat := range []string{"‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û", "‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô", "‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô", "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å"} {
										if breakdown, ok := props.CategoryBreakdown[cat]; ok {
											// Row 1: Metrics & Toggle
											<tr style={ fmt.Sprintf("background-color: %s;", func() string { if i%2 != 0 { return "#f8f9fa" }; return "#ffffff" }()) }>
												<td style="padding: 12px 8px; font-weight: 700; color: #1e293b; display: flex; align-items: center; gap: 8px;">
													if cat == "‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô" {
														<span style="display: inline-block; width: 14px; height: 14px; min-width: 14px; border-radius: 4px; background-color: #4158D0;"></span>
													} else if cat == "‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô" {
														<span style="display: inline-block; width: 14px; height: 14px; min-width: 14px; border-radius: 4px; background-color: #FB8C00;"></span>
													} else if cat == "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å" {
														<span style="display: inline-block; width: 14px; height: 14px; min-width: 14px; border-radius: 4px; background-color: #D4145A;"></span>
													} else if cat == "‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û" {
														<span style="display: inline-block; width: 14px; height: 14px; min-width: 14px; border-radius: 4px; background-color: #00DBDE;"></span>
													} else {
														<span style="display: inline-block; width: 14px; height: 14px; min-width: 14px; border-radius: 4px; background-color: #A0A0A0;"></span>
													}
													{ cat }
												</td>
												<td style="text-align: right; padding: 12px 8px;" id={ fmt.Sprintf("good-score-container-%s-%s", props.CleanedName, cat) } data-base-good={ fmt.Sprintf("%.0f", (float64(breakdown.Good) / float64(len(props.NumerologyPairs) + len(props.ShadowPairs))) * 100) }>
													if breakdown.Good > 0 {
														<span class="good-score-wrap" style="color: #2E7D32; font-weight: 700; font-size: 1.1em; display: flex; align-items: center; justify-content: flex-end; gap: 4px;">
															<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
															<span class="good-value-text">{ fmt.Sprintf("%.0f%%", (float64(breakdown.Good) / float64(len(props.NumerologyPairs) + len(props.ShadowPairs))) * 100) }</span>
														</span>
													} else {
														<span class="good-score-wrap" style="color: #ccc;">-</span>
													}
												</td>
												<td style="text-align: right; padding: 12px 8px;">
													if breakdown.Bad > 0 {
														<span style="color: #C62828; font-weight: 700; font-size: 1.1em; display: flex; align-items: center; justify-content: flex-end; gap: 4px;">
															<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
															{ fmt.Sprintf("%.0f%%", (float64(breakdown.Bad) / float64(len(props.NumerologyPairs) + len(props.ShadowPairs))) * 100) }
														</span>
													} else {
														<span style="color: #ccc;">-</span>
													}
												</td>
												<td style="text-align: center; padding: 12px 8px;">
													<button 
														class="btn-icon-lucky" 
														style="display: inline-flex; align-items: center; justify-content: center; width: 32px; height: 32px; border-radius: 50%; border: none; background-color: #f5f5f5; color: #666; cursor: pointer; transition: all 0.2s;"
														onclick={ templ.JSFuncCall("toggleLuckyNumber", cat, fmt.Sprintf("lucky-container-%s-%s", props.CleanedName, cat)) }
													>
														<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
															<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
															<line x1="12" y1="18" x2="12.01" y2="18"></line>
														</svg>
													</button>
												</td>
											</tr>
											// Row 2: Content (Keywords & Lucky Card) - Full Width
											<tr style={ fmt.Sprintf("border-bottom: 1px solid #eee; background-color: %s;", func() string { if i%2 != 0 { return "#f8f9fa" }; return "#ffffff" }()) }>
												<td colspan="4" style="padding: 0 12px 12px 12px;">
													if len(breakdown.Keywords) > 0 {
														<div style="font-size: 0.8rem; color: #64748b; margin-bottom: 8px; line-height: 1.4; padding-left: 22px; border-left: 2px solid rgba(0,0,0,0.05);">
															{ strings.Join(breakdown.Keywords, ", ") }
														</div>
													}
													<div id={ fmt.Sprintf("lucky-container-%s-%s", props.CleanedName, cat) } style="width: 100%; display: flex; justify-content: center;">
														<!-- Placeholder or small sparkler for 100% -->
														<span class="sparkling-gold" 
															style="font-size: 0.7rem; display: flex; align-items: center; gap: 2px; padding: 2px 8px; border-radius: 10px; cursor: pointer; opacity: 0.8;"
															onclick={ templ.JSFuncCall("toggleLuckyNumber", cat, fmt.Sprintf("lucky-container-%s-%s", props.CleanedName, cat)) }
														>
															<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="#8B4513" stroke="none"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
															‡πÄ‡∏™‡∏£‡∏¥‡∏°‡πÄ‡∏ö‡∏≠‡∏£‡πå 100% ‚ú®
														</span>
													</div>
												</td>
											</tr>
										}
									}
									<!-- Total Score Row -->
									<tr style="border-top: 2px solid #e2e8f0; background: linear-gradient(to right, #f8faff, #eff6ff); border-bottom: 2px solid #e2e8f0;">
										<td style="padding: 14px 10px; font-weight: 800; color: #1e293b; font-size: 1rem; text-align: left;" colspan="1">%‡∏£‡∏ß‡∏°</td>
										<td style="text-align: center; padding: 14px 10px;" colspan="3">
											<div id={ fmt.Sprintf("total-score-%s", props.CleanedName) } data-base-score={ fmt.Sprintf("%.0f", props.GetLinguisticTotalScore()) } style={ fmt.Sprintf("font-weight: 900; font-size: 1.4rem; color: %s; display: flex; align-items: center; justify-content: center; gap: 8px; text-shadow: 0 1px 2px rgba(0,0,0,0.05);", props.GetLinguisticScoreColor()) }>
												<span class="score-icon">
													if props.GetLinguisticTotalScore() > 0 {
														<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#FFD700" stroke="#B8860B" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1));">
															<path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
															<path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
															<path d="M4 22h16"></path>
															<path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
															<path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
															<path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
														</svg>
													} else {
														<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#e0e0e0" stroke="#bdbdbd" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="filter: grayscale(1); opacity: 0.7;">
															<path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
															<path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
															<path d="M4 22h16"></path>
															<path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
															<path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
															<path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
														</svg>
													}
												</span>
												<span class="score-value">{ fmt.Sprintf("%.0f%%", props.GetLinguisticTotalScore()) }</span>
											</div>
										</td>
										<td style="background: transparent;"></td>
									</tr>
								</tbody>
							</table>
						</div>
					</div>
				</div>
			</div>
			@DrawNestedDonut("nested-donut-" + props.CleanedName, props.GetCategoryBreakdownJSON())
		}

		</div>

	<!-- Modals -->
	<div id={ "meaning-modal-" + props.CleanedName } class="modal-overlay" onclick="this.style.display='none'">
		<div class="modal-content" onclick="event.stopPropagation()">
			<div class="modal-header">
				<h2 class="modal-header-title" style="display: flex; align-items: center; gap: 2px;">
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
						stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
						<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
						<rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
						<path d="M12 11h4"></path>
						<path d="M12 16h4"></path>
						<path d="M8 11h.01"></path>
						<path d="M8 16h.01"></path>
					</svg>
					<span style="margin-right: 4px;">‡πÄ‡∏•‡∏Ç‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‡∏Ç‡∏≠‡∏á</span>
					<div style="display: flex;">
					for _, dc := range props.SunDisplayNameHTML {
						if dc.IsBad {
							<span class="klakini-char klakini-red">{ dc.Char }</span>
						} else {
							<span>{ dc.Char }</span>
						}
					}
					</div>
				</h2>
				<button class="close-btn" { templ.Attributes{"onclick": fmt.Sprintf("closeMeaningModal('%s')", props.CleanedName)}... }>&times;</button>
			</div>
			<div class="modal-body">
				
				<!-- Category Chart in Modal - Nested Donut -->
				if len(props.CategoryBreakdown) > 0 {
					<div class="category-breakdown-container" style="margin-bottom: 2rem; background: #fbfbfb;">

						<div class="nested-donut-layout" style="display: flex; flex-direction: row; gap: 1.5rem; align-items: center; justify-content: center; flex-wrap: wrap;">
							<div class="nested-donut-wrapper">
								<svg class="nested-donut-chart" viewBox="0 0 200 200" id={ "modal-nested-donut-" + props.CleanedName } style="width: 200px; height: 200px;">
									<g class="inner-ring"></g>

									<text x="100" y="95" text-anchor="middle" class="donut-center-number">
										{ fmt.Sprintf("%d", len(props.NumerologyPairs) + len(props.ShadowPairs)) }
									</text>
									<text x="100" y="110" text-anchor="middle" class="donut-center-label">‡∏Ñ‡∏π‡πà‡πÄ‡∏•‡∏Ç</text>
								</svg>
							</div>
							<div class="nested-legend" style="min-width: 250px;">
						<div class="breakdown-summary" style="margin-top: 0.5rem;">
									<table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
								<thead>
									<tr style="border-bottom: 2px solid #f0f0f0;">
										<th style="text-align: left; padding: 8px; color: #555;">‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà</th>
										<th style="text-align: right; padding: 8px; color: #333; width: 60px;">%‡∏î‡∏µ</th>
										<th style="text-align: right; padding: 8px; color: #333; width: 60px;">%‡∏£‡πâ‡∏≤‡∏¢</th>
										<th style="text-align: center; padding: 8px; color: #333; width: 80px;">‡πÄ‡∏™‡∏£‡∏¥‡∏°‡πÄ‡∏ö‡∏≠‡∏£‡πå</th>
									</tr>
								</thead>
								<tbody>
									for i, cat := range []string{"‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û", "‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô", "‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô", "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å"} {
										if breakdown, ok := props.CategoryBreakdown[cat]; ok {
											// Row 1: Metrics & Toggle
											<tr style={ fmt.Sprintf("background-color: %s;", func() string { if i%2 != 0 { return "#f8f9fa" }; return "#ffffff" }()) }>
												<td style="padding: 12px 8px; font-weight: 700; color: #1e293b; display: flex; align-items: center; gap: 8px;">
													if cat == "‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô" {
														<span style="display: inline-block; width: 14px; height: 14px; min-width: 14px; border-radius: 4px; background-color: #4158D0;"></span>
													} else if cat == "‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô" {
														<span style="display: inline-block; width: 14px; height: 14px; min-width: 14px; border-radius: 4px; background-color: #FB8C00;"></span>
													} else if cat == "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å" {
														<span style="display: inline-block; width: 14px; height: 14px; min-width: 14px; border-radius: 4px; background-color: #D4145A;"></span>
													} else if cat == "‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û" {
														<span style="display: inline-block; width: 14px; height: 14px; min-width: 14px; border-radius: 4px; background-color: #00DBDE;"></span>
													} else {
														<span style="display: inline-block; width: 14px; height: 14px; min-width: 14px; border-radius: 4px; background-color: #A0A0A0;"></span>
													}
													{ cat }
												</td>
												<td style="text-align: right; padding: 12px 8px;" id={ fmt.Sprintf("modal-good-score-container-%s-%s", props.CleanedName, cat) } data-base-good={ fmt.Sprintf("%.0f", (float64(breakdown.Good) / float64(len(props.NumerologyPairs) + len(props.ShadowPairs))) * 100) }>
													if breakdown.Good > 0 {
														<span class="good-score-wrap" style="color: #2E7D32; font-weight: 700; font-size: 1.1em; display: flex; align-items: center; justify-content: flex-end; gap: 4px;">
															<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
															<span class="good-value-text">{ fmt.Sprintf("%.0f%%", (float64(breakdown.Good) / float64(len(props.NumerologyPairs) + len(props.ShadowPairs))) * 100) }</span>
														</span>
													} else {
														<span class="good-score-wrap" style="color: #ccc;">-</span>
													}
												</td>
												<td style="text-align: right; padding: 12px 8px;">
													if breakdown.Bad > 0 {
														<span style="color: #C62828; font-weight: 700; font-size: 1.1em; display: flex; align-items: center; justify-content: flex-end; gap: 4px;">
															<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
															{ fmt.Sprintf("%.0f%%", (float64(breakdown.Bad) / float64(len(props.NumerologyPairs) + len(props.ShadowPairs))) * 100) }
														</span>
													} else {
														<span style="color: #ccc;">-</span>
													}
												</td>
												<td style="text-align: center; padding: 12px 8px;">
													<button 
														class="btn-icon-lucky" 
														style="display: inline-flex; align-items: center; justify-content: center; width: 32px; height: 32px; border-radius: 50%; border: none; background-color: #f5f5f5; color: #666; cursor: pointer; transition: all 0.2s;"
														onclick={ templ.JSFuncCall("toggleLuckyNumber", cat, fmt.Sprintf("modal-lucky-container-%s-%s", props.CleanedName, cat)) }
													>
														<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
															<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
															<line x1="12" y1="18" x2="12.01" y2="18"></line>
														</svg>
													</button>
												</td>
											</tr>
											// Row 2: Content (Keywords & Lucky Card) - Full Width
											<tr style={ fmt.Sprintf("border-bottom: 1px solid #eee; background-color: %s;", func() string { if i%2 != 0 { return "#f8f9fa" }; return "#ffffff" }()) }>
												<td colspan="4" style="padding: 0 12px 12px 12px;">
													if len(breakdown.Keywords) > 0 {
														<div style="font-size: 0.8rem; color: #64748b; margin-bottom: 8px; line-height: 1.4; padding-left: 22px; border-left: 2px solid rgba(0,0,0,0.05);">
															{ strings.Join(breakdown.Keywords, ", ") }
														</div>
													}
													<div id={ fmt.Sprintf("modal-lucky-container-%s-%s", props.CleanedName, cat) } style="width: 100%; display: flex; justify-content: center;">
														<span class="sparkling-gold" 
															style="font-size: 0.7rem; display: flex; align-items: center; gap: 2px; padding: 2px 8px; border-radius: 10px; cursor: pointer; opacity: 0.8;"
															onclick={ templ.JSFuncCall("toggleLuckyNumber", cat, fmt.Sprintf("modal-lucky-container-%s-%s", props.CleanedName, cat)) }
														>
															<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="#8B4513" stroke="none"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
															‡πÄ‡∏™‡∏£‡∏¥‡∏°‡πÄ‡∏ö‡∏≠‡∏£‡πå 100% ‚ú®
														</span>
													</div>
												</td>
											</tr>
										}
									}
									<!-- Total Score Row -->
									<tr style="border-top: 2px solid #e2e8f0; background: linear-gradient(to right, #f8faff, #eff6ff); border-bottom: 2px solid #e2e8f0;">
										<td style="padding: 14px 10px; font-weight: 800; color: #1e293b; font-size: 1rem; text-align: left;" colspan="1">%‡∏£‡∏ß‡∏°</td>
										<td style="text-align: center; padding: 14px 10px;" colspan="3">
											<div id={ fmt.Sprintf("modal-total-score-%s", props.CleanedName) } data-base-score={ fmt.Sprintf("%.0f", props.GetLinguisticTotalScore()) } style={ fmt.Sprintf("font-weight: 900; font-size: 1.4rem; color: %s; display: flex; align-items: center; justify-content: center; gap: 8px; text-shadow: 0 1px 2px rgba(0,0,0,0.05);", props.GetLinguisticScoreColor()) }>
												<span class="score-icon">
													if props.GetLinguisticTotalScore() > 0 {
														<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#FFD700" stroke="#B8860B" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1));">
															<path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
															<path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
															<path d="M4 22h16"></path>
															<path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
															<path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
															<path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
														</svg>
													} else {
														<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#e0e0e0" stroke="#bdbdbd" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="filter: grayscale(1); opacity: 0.7;">
															<path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
															<path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
															<path d="M4 22h16"></path>
															<path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
															<path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
															<path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
														</svg>
													}
												</span>
												<span class="score-value">{ fmt.Sprintf("%.0f%%", props.GetLinguisticTotalScore()) }</span>
											</div>
										</td>
										<td style="background: transparent;"></td>
									</tr>
								</tbody>
									</table>
								</div>
							</div>
						</div>
					</div>
					@DrawNestedDonut("modal-nested-donut-" + props.CleanedName, props.GetCategoryBreakdownJSON())
				}

				<h3>‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£</h3>
				<table class="similar-names-table">
					<thead>
						<tr>
							<th>‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£</th>
							<th>‡πÄ‡∏•‡∏Ç‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå</th>
							<th>‡∏û‡∏•‡∏±‡∏á‡πÄ‡∏á‡∏≤</th>
						</tr>
					</thead>
					<tbody>
						for _, part := range props.DecodedParts {
							<tr>
								<td>
									if part.IsKlakini {
										<span class="klakini-char">{ part.Character }</span>
									} else {
										{ part.Character }
									}
								</td>
								<td>{ fmt.Sprintf("%d", part.NumerologyValue) }</td>
								<td>{ fmt.Sprintf("%d", part.ShadowValue) }</td>
							</tr>
						}
					</tbody>
				</table>

				<h3 class="modal-section-title">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢‡∏Ñ‡∏π‡πà‡πÄ‡∏•‡∏Ç</h3>
				if len(props.AllUniquePairs) > 0 {
					for i, pair := range props.AllUniquePairs {
						if props.IsVIP || i <= 2 {
						<div class="meaning-item">
							<div class="meaning-header">
								<span class="pair-number-badge" style={ "background-color: " + pair.Meaning.Color + ";" }>{ pair.PairNumber }</span>
								<span class="pair-desc">{ pair.Meaning.MiracleDesc }</span>
							</div>
							<div class={ "meaning-content", templ.KV("blur-content", !props.IsVIP && i >= 2), templ.KV("user-select-none", !props.IsVIP && i >= 2)}
							>
								<p>{ pair.Meaning.MiracleDetail }</p>
							</div>
						</div>
						}
					}
					if !props.IsVIP && len(props.AllUniquePairs) > 2 {
						<div class="vip-upgrade-overlay vip-overlay-container">
							<div class="vip-lock-badge">
								üîí ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ô‡∏µ‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å VIP
							</div>
							<div class="vip-link-container">
								<a href="#" 
								   hx-get="/payment/upgrade" 
								   hx-target="#upgrade-modal-container" 
								   hx-swap="innerHTML"
								   onclick="event.preventDefault(); document.getElementById('upgrade-modal-container').style.display='flex'"
								   class="vip-link">‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å VIP ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡πà‡∏≤‡∏ô‡∏ï‡πà‡∏≠</a>
							</div>
						</div>
					}
				} else {
					<p>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</p>
				}
			</div>
		</div>
	</div>

	<div id="linguistic-modal-container" class="modal-overlay" onclick="this.style.display='none'" style="z-index: 10000;">
		<div id="linguistic-modal-content" class="modal-content" onclick="event.stopPropagation()">
			<div id="linguistic-loader" class="htmx-indicator linguistic-loader-container">
				<svg class="spinner" width="40px" height="40px" viewBox="0 0 66 66" xmlns="http://www.w3.org/2000/svg">
					<circle class="path stroke-primary-important" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle>
				</svg>
				<p class="linguistic-loading-text">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå...</p>
			</div>
		</div>
	</div>

	<!-- Purchase Modal -->
	<div id="purchase-modal" class="modal-overlay" onclick="this.style.display='none'" style="z-index: 10001;">
		<div class="modal-content" onclick="event.stopPropagation()" style="max-width: 400px; text-align: center; padding: 2rem; border-radius: 24px; background: linear-gradient(135deg, #ffffff 0%, #f9fdf9 100%);">
			<div style="margin-bottom: 1.5rem;">
				<div style="width: 70px; height: 70px; background: #E8F5E9; border-radius: 20px; display: flex; align-items: center; justify-content: center; margin: 0 auto 1.2rem; transform: rotate(-10deg); box-shadow: 0 4px 10px rgba(46, 125, 50, 0.1);">
					<svg xmlns="http://www.w3.org/2000/svg" width="34" height="34" viewBox="0 0 24 24" fill="none" stroke="#2E7D32" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"/><circle cx="20" cy="21" r="1"/><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"/></svg>
				</div>
				<h2 style="color: #1B5E20; margin-bottom: 0.8rem; font-size: 1.6rem; font-weight: 800;">‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡πÄ‡∏ö‡∏≠‡∏£‡πå‡∏°‡∏á‡∏Ñ‡∏•</h2>
				<p style="color: #444; font-size: 0.95rem; line-height: 1.6;">‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏™‡∏≠‡∏ö‡∏ñ‡∏≤‡∏°‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏Å‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏ç‡∏≤ <br/>‡∏ó‡∏≤‡∏á LINE ‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡∏ú‡πà‡∏≤‡∏ô QR Code ‡∏ô‡∏µ‡πâ‡∏Ñ‡∏£‡∏±‡∏ö</p>
			</div>
			
			<div style="background: white; padding: 12px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.06); display: inline-block; margin-bottom: 1.8rem; border: 1px solid rgba(0,0,0,0.03); position: relative;">
				<img src="/images/line_qr_taya.jpg" alt="LINE QR Code" style="width: 220px; height: 220px; display: block; border-radius: 12px;"/>
				<div style="position: absolute; bottom: -10px; right: -10px; background: #06C755; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; box-shadow: 0 4px 10px rgba(6, 199, 85, 0.3);">
					<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M24 10.304c0-5.369-5.383-9.738-12-9.738-6.616 0-12 4.369-12 9.738 0 4.814 4.269 8.846 10.036 9.608.391.084.922.258 1.183.593.227.292.149.75.073 1.047l-.314 1.328c-.095.402-.439 1.574 1.887.859 2.327-.715 12.553-7.391 12.553-13.435z"/></svg>
				</div>
			</div>

			<div style="display: flex; flex-direction: column; gap: 12px; width: 100%;">
				<button onclick="document.getElementById('purchase-modal').style.display='none'" style="background: #1B5E20; color: white; border: none; padding: 14px; border-radius: 14px; font-weight: 700; cursor: pointer; transition: all 0.2s; font-size: 1rem; box-shadow: 0 4px 12px rgba(27, 94, 32, 0.2);">
					‡∏ï‡∏Å‡∏•‡∏á
				</button>
				<p style="font-size: 0.75rem; color: #999;">‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡πÑ‡∏ß‡πâ‡∏ß‡∏≤‡∏á‡πÉ‡∏à‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏ç‡∏≤‡∏î‡∏π‡πÅ‡∏•‡∏Ñ‡∏£‡∏±‡∏ö</p>
			</div>
		</div>
	</div>


	<script>
		function openMeaningModal(name) {
			document.getElementById('meaning-modal-' + name).style.display = 'flex';
		}
		
		function loadLinguisticAnalysis(name) {
			// 1. Show Modal & Loader
			const modal = document.getElementById('linguistic-modal-container');
			const contentDiv = document.getElementById('linguistic-modal-content');
			
			modal.style.display = 'flex';
			modal.style.zIndex = '10000';
			
			// Reset content to loader
			// Reset content to loader with premium design
			// Reset content to loader with premium design
			contentDiv.innerHTML = `
				<div id="linguistic-loader" class="linguistic-loader-container" style="display: flex !important; flex-direction: column; align-items: center; justify-content: center; padding: 3rem 2rem; min-height: 300px;">
					<div class="loader-spinner" style="
						border: 4px solid #f3f3f3;
						border-top: 4px solid #DB4437;
						border-radius: 50%;
						width: 50px;
						height: 50px;
						animation: spin 1s linear infinite;
						margin-bottom: 20px;
					"></div>
					<h3 style="color: #333; margin-bottom: 10px; font-weight: 600;">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</h3>
					<p class="linguistic-loading-text" style="color: #666; font-size: 0.9em; text-align: center;">‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå<br>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà...</p>
					<style>
						@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
					</style>
				</div>
			`;

			// 2. Fetch Data
			fetch('/linguistic-analysis?name=' + encodeURIComponent(name))
				.then(async response => {
					if (!response.ok) {
						// Try to get error text from server
						const errorText = await response.text();
						throw new Error(errorText || 'Network response was not ok');
					}
					return response.text();
				})
				.then(html => {
					// 3. Update Content
					contentDiv.innerHTML = html;
				})
				.catch(error => {
					console.error('Error fetching linguistic analysis:', error);
					// Display detailed error message
					contentDiv.innerHTML = `
						<div class="modal-body" style="text-align: center; padding: 2rem; color: #d32f2f;">
							<p>‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</p>
							<p style="font-size: 0.8em; color: #555; margin-top: 10px;">${error.message}</p>
							<button class="action-btn-premium" onclick="document.getElementById('linguistic-modal-container').style.display='none'" style="margin-top: 1rem;">‡∏õ‡∏¥‡∏î</button>
						</div>
					`;
				});
		}
		function closeMeaningModal(name) {
			document.getElementById('meaning-modal-' + name).style.display = 'none';
		}
	</script>

	<script>
		window.defaultLuckyIcons = window.defaultLuckyIcons || {};

		function updateScores(containerId) {
			// containerId format: "lucky-container-{name}-{cat}" or "modal-lucky-container-{name}-{cat}"
			let isModal = containerId.startsWith('modal-');
			let parts = containerId.split('-');
			
			let prefixLen = isModal ? 3 : 2;
			let name = parts.slice(prefixLen, -1).join('-');
			let cat = parts[parts.length - 1];
			
			// 1. Update Total Score (%‡∏£‡∏ß‡∏°)
			let scoreId = isModal ? `modal-total-score-${name}` : `total-score-${name}`;
			let scoreElement = document.getElementById(scoreId);
			if (scoreElement) {
				let baseScore = parseInt(scoreElement.getAttribute('data-base-score') || '0');
				let prefix = isModal ? `modal-lucky-container-${name}-` : `lucky-container-${name}-`;
				let activeLuckyCount = 0;
				document.querySelectorAll(`[id^="${prefix}"]`).forEach(el => {
					if (el.getAttribute('data-showing-number') === 'true') {
						activeLuckyCount++;
					}
				});

				let newScore = baseScore + (activeLuckyCount * 100);
				
				// Handle Sparkling Effect for Total Score
				if (activeLuckyCount > 0) {
					scoreElement.classList.add('sparkling-gold');
					scoreElement.style.padding = '10px 20px';
					scoreElement.style.borderRadius = '15px';
				} else {
					scoreElement.classList.remove('sparkling-gold');
					scoreElement.style.padding = '';
					scoreElement.style.borderRadius = '';
				}

				let valueSpan = scoreElement.querySelector('.score-value');
				if (valueSpan) {
					valueSpan.textContent = newScore + '%' + (activeLuckyCount > 0 ? ' ‚ú®' : '');
				}

				let iconSpan = scoreElement.querySelector('.score-icon');
				if (iconSpan) {
					if (activeLuckyCount > 0) {
						iconSpan.innerHTML = '';
					} else {
						if (newScore > 0) {
							iconSpan.innerHTML = `
								<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#FFD700" stroke="#B8860B" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1));">
									<path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
									<path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
									<path d="M4 22h16"></path>
									<path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
									<path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
									<path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
								</svg>
							`;
						} else {
							iconSpan.innerHTML = `
								<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#e0e0e0" stroke="#bdbdbd" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="filter: grayscale(1); opacity: 0.7;">
									<path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
									<path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
									<path d="M4 22h16"></path>
									<path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
									<path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
									<path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
								</svg>
							`;
						}
					}
				}
			}

			// 2. Update Category %‡∏î‡∏µ
			let goodId = isModal ? `modal-good-score-container-${name}-${cat}` : `good-score-container-${name}-${cat}`;
			let goodContainer = document.getElementById(goodId);
			if (goodContainer) {
				let baseGood = parseInt(goodContainer.getAttribute('data-base-good') || '0');
				let luckyContainer = document.getElementById(containerId);
				let isShowing = luckyContainer.getAttribute('data-showing-number') === 'true';
				let newGood = baseGood + (isShowing ? 100 : 0);
				
				if (newGood > 0) {
					let isLuckySelection = luckyContainer.getAttribute('data-showing-number') === 'true';
					let goldClass = isLuckySelection ? 'sparkling-gold' : '';
					let goldStyle = isLuckySelection ? 'padding: 2px 8px; border-radius: 12px;' : '';
					
					goodContainer.innerHTML = `
						<span class="good-score-wrap ${goldClass}" style="color: #2E7D32; font-weight: 700; font-size: 1.1em; display: flex; align-items: center; justify-content: flex-end; gap: 4px; ${goldStyle}">
							${isLuckySelection ? '' : '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>'}
							<span class="good-value-text">${newGood}%</span>
							${isLuckySelection ? '‚ú®' : ''}
						</span>
					`;
				} else {
					goodContainer.innerHTML = '<span class="good-score-wrap" style="color: #ccc;">-</span>';
				}
			}
		}

		function revertLuckyNumber(containerId) {
			const container = document.getElementById(containerId);
			if (container && window.defaultLuckyIcons[containerId]) {
				container.innerHTML = window.defaultLuckyIcons[containerId];
				container.setAttribute('data-showing-number', 'false');
				updateScores(containerId);
			}
		}

		async function toggleLuckyNumber(category, containerId) {
			console.log("Toggling lucky number for:", category, "at", containerId);
			const container = document.getElementById(containerId);
			if (!container) return;

			// Store default state if not already stored
			if (!window.defaultLuckyIcons[containerId]) {
				window.defaultLuckyIcons[containerId] = container.innerHTML;
			}

			// If it's already showing a number, revert to default icon
			if (container.getAttribute('data-showing-number') === 'true') {
				revertLuckyNumber(containerId);
				return;
			}

			try {
				// Loading state
				container.innerHTML = '<div class="animate-spin" style="width: 16px; height: 16px; border: 2px solid #ccc; border-top-color: #333; border-radius: 50%;"></div>';


				const response = await fetch(`/api/lucky-number?category=${encodeURIComponent(category)}`);
				const data = await response.json();

				if (data && data.number) {
					console.log("Found lucky number:", data.number, "with keywords:", data.keywords);
					
					let keywordsHtml = "";
					if (data.keywords && data.keywords.length > 0) {
						keywordsHtml = `
							<div style="font-size: 0.7rem; color: #558B2F; font-weight: 500; line-height: 1.3; text-align: center; width: 100%; max-width: 250px; background: rgba(255,255,255,0.5); padding: 4px 8px; border-radius: 6px;">
								${data.keywords.join(' ‚Ä¢ ')}
							</div>
						`;
					}

					container.innerHTML = `
						<div class="lucky-card" style="position: relative; display: flex; width: 100%; box-sizing: border-box; flex-direction: column; align-items: center; background: #F1F8E9; padding: 16px 12px; border-radius: 12px; border: 1px solid #C8E6C9; animation: fadeIn 0.3s; gap: 8px; box-shadow: 0 4px 12px rgba(46, 125, 50, 0.08);">
							<div style="font-weight: 900; color: #1B5E20; font-size: 1.2rem; white-space: nowrap; line-height: 1; letter-spacing: 0.8px; text-shadow: 0 1px 0 white;">
								${data.number}
							</div>
							${keywordsHtml}
							<div style="display: flex; gap: 6px; width: 100%; justify-content: center; margin-top: 4px;">
								<button onclick="event.stopPropagation(); openPurchaseModal()" style="background: #2E7D32; color: white; padding: 6px 12px; border-radius: 8px; font-size: 0.75rem; font-weight: 700; display: inline-flex; align-items: center; gap: 4px; transition: all 0.2s; border: 1px solid #1B5E20; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer;">
									<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"/><circle cx="20" cy="21" r="1"/><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"/></svg>
									‡∏ã‡∏∑‡πâ‡∏≠‡πÄ‡∏ö‡∏≠‡∏£‡πå
								</button>
								<button onclick="event.stopPropagation(); revertLuckyNumber('${containerId}')" style="background: #fff; color: #D32F2F; padding: 6px 10px; border-radius: 8px; font-size: 0.75rem; font-weight: 700; cursor: pointer; border: 1px solid #FFCDD2; display: inline-flex; align-items: center; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
									‡∏•‡∏ö
								</button>
							</div>
						</div>
					`;
					container.setAttribute('data-showing-number', 'true');
					updateScores(containerId);
				} else {
					console.warn("No lucky number found for category:", category);
					revertLuckyNumber(containerId);
					alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏ö‡∏≠‡∏£‡πå‡∏°‡∏á‡∏Ñ‡∏•‡πÉ‡∏ô‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ');
				}
			} catch (error) {
				console.error('Error fetching lucky number:', error);
				revertLuckyNumber(containerId);
			}
		}
		function openPurchaseModal() {
			document.getElementById('purchase-modal').style.display = 'flex';
		}
	</script>


	<!-- Auto-trigger similar names update when solar system renders -->
	if !props.SkipTrigger {
		<div class="display-none" 
			hx-get="/similar-names" 
			hx-trigger="load" 
			hx-include="#name-form" 
			hx-target="#results" 
			hx-indicator="#results-wrapper">
		</div>
	}
}
