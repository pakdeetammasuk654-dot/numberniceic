package analysis

import (
	"numberniceic/internal/core/domain"
    "numberniceic/views/components"
	"strings"
)

type IndexProps struct {
    HeaderDisplayNameHTML []domain.DisplayChar // New field for header rendering
    Layout      LayoutProps
    DefaultName string
    DefaultDay  string
    SampleNames []domain.SampleName
	SolarSystem SolarSystemProps
	IsVIP       bool
    Results     templ.Component
    SolarSystemInitial templ.Component // Added for lazy loading
}

templ Index(props IndexProps) {
	@Layout(props.Layout) {


		
		<!-- Analyzer Form Container -->
		<div class="analyzer-container-premium">
		
			<form id="name-form">
				<!-- Hidden inputs -->
				<input type="hidden" name="auspicious" id="main-auspicious" value="false"/>
				<input type="hidden" name="disable_klakini" id="main-disable-klakini" value="false"/>
		
				<div class="form-group">
					<div class="label-row">
						<label for="name">ชื่อ</label>
						<small class="helper-text">วิเคราะห์อัตโนมัติเมื่อพิมพ์ชื่อ</small>
					</div>
					<div class="input-wrapper">
						<span class="input-icon">
							<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
								stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"></path>
								<circle cx="12" cy="7" r="4"></circle>
							</svg>
						</span>
						<input type="text" id="name" name="name" required placeholder="เช่น ปัญญา" value={ props.DefaultName } maxlength="30"
							class="input-premium"
							oninput="toggleClearButton()" hx-get="/decode" hx-target="#solar-system-wrapper" hx-include="#name-form"
							hx-trigger="input changed delay:500ms" hx-indicator="#solar-loading, #results-wrapper"/>
						<span id="clear-btn" class="clear-btn" onclick="clearName()">×</span>
					</div>
				</div>
		
				<div class="form-group">
					<label for="day">วันเกิด</label>
					<div class="input-wrapper">
						<span class="input-icon">
							<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
								stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<rect width="18" height="18" x="3" y="4" rx="2" ry="2"></rect>
								<line x1="16" x2="16" y1="2" y2="6"></line>
								<line x1="8" x2="8" y1="2" y2="6"></line>
								<line x1="3" x2="21" y1="10" y2="10"></line>
							</svg>
						</span>
						<select id="day" name="day" required
							class="select-premium"
							hx-get="/decode"
							hx-target="#solar-system-wrapper" hx-include="#name-form" hx-trigger="change" hx-indicator="#solar-loading, #results-wrapper">
							<option value="SUNDAY" if props.DefaultDay == "SUNDAY" { selected }>วันอาทิตย์</option>
							<option value="MONDAY" if props.DefaultDay == "MONDAY" { selected }>วันจันทร์</option>
							<option value="TUESDAY" if props.DefaultDay == "TUESDAY" { selected }>วันอังคาร</option>
							<option value="WEDNESDAY1" if props.DefaultDay == "WEDNESDAY1" { selected }>วันพุธ (กลางวัน)</option>
							<option value="WEDNESDAY2" if props.DefaultDay == "WEDNESDAY2" { selected }>วันพุธ (กลางคืน)</option>
							<option value="THURSDAY" if props.DefaultDay == "THURSDAY" { selected }>วันพฤหัสบดี</option>
							<option value="FRIDAY" if props.DefaultDay == "FRIDAY" { selected }>วันศุกร์</option>
							<option value="SATURDAY" if props.DefaultDay == "SATURDAY" { selected }>วันเสาร์</option>
						</select>
					</div>
				</div>
			</form>
		</div>

		<!-- Sample Names Section -->
		<div class="sample-names-container" style="max-width: 100%; overflow: hidden; position: relative; mask-image: linear-gradient(to right, transparent, black 10%, black 90%, transparent); -webkit-mask-image: linear-gradient(to right, transparent, black 10%, black 90%, transparent);">
			<div class="avatars-grid" id="avatars-grid" style="display: flex; overflow-x: auto; gap: 20px; padding: 20px 0; -ms-overflow-style: none; scrollbar-width: none; cursor: grab;">
				for _, sample := range props.SampleNames {
					<div class={ "avatar-premium", templ.KV("active", strings.TrimSpace(sample.Name) == strings.TrimSpace(props.DefaultName)) } 
						data-name={ strings.TrimSpace(sample.Name) }
						{ templ.Attributes{"onclick": "selectName('" + strings.TrimSpace(sample.Name) + "')" }... }
                        style="flex: 0 0 auto; min-width: 80px; transition: transform 0.2s;">
						<img src={ sample.AvatarURL } alt="Avatar" class="avatar-img" style="width: 60px; height: 60px; object-fit: cover; border-radius: 50%; box-shadow: 0 4px 10px rgba(0,0,0,0.1); border: 2px solid white; pointer-events: none;"/>
						<div class="avatar-name" style="margin-top: 8px; font-size: 0.9rem; color: #4a5568; font-weight: 500; pointer-events: none;">{ sample.Name }</div>
					</div>
				}
			</div>
		</div>


		<!-- Results Section for initial load and as a target -->
		<div id="results-container">
			<div class="result-container-relative">
				<div id="solar-loading" class="htmx-indicator loading-overlay">
					<div class="loading-content">
						<svg class="spinner" width="35px" height="35px" viewBox="0 0 66 66" xmlns="http://www.w3.org/2000/svg">
							<circle class="path stroke-primary-important" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle>
						</svg>
						<span class="loading-text-lg"><strong style="color: #f57f17; font-size: 1.2em;">โปรดรอสักครู่</strong><br/>กำลังวิเคราะห์จาก 3 แสนรายชื่อ....</span>
					</div>
				</div>
				<div id="solar-system-wrapper">
					if props.SolarSystemInitial != nil {
						@props.SolarSystemInitial
					} else {
						@SolarSystem(props.SolarSystem)
					}
				</div>
			</div>
			
			<div id="results-wrapper" class="htmx-indicator-container">

				<!-- Table Loading Indicator (Skeleton) -->
				<div id="table-loading" class="htmx-indicator">
					@Top4Skeleton()
					@Skeleton("similar-names-skeleton")
				</div>

				<div id="results">
					<!-- This is where the streaming data will be injected -->
					@props.Results
				</div>
                
                <!-- Call to Action Section -->
                <div style="margin-top: 4rem; margin-bottom: 2rem;">
                    @components.MobileAppCTA()
                </div>
			</div>
		</div>
		
		<script>
            (function() {
                // Use IIFE to avoid global scope pollution
                function initAvatarScroll() {
                    const grid = document.getElementById('avatars-grid');
                    if (!grid) {
                        console.log("Avatar grid not found, retrying...");
                        setTimeout(initAvatarScroll, 500); // Retry if not found immediately
                        return;
                    }

                    // Avoid double initialization
                    if (grid.dataset.scrollInit === "true") return;
                    grid.dataset.scrollInit = "true";

                    // Clone children for infinite scroll
                    const originalChildren = Array.from(grid.children);
                    
                    // Clone enough times to cover screen width + buffer
                    // Simple approach: Triple the content
                    originalChildren.forEach(child => {
                        grid.appendChild(child.cloneNode(true));
                    });
                    originalChildren.forEach(child => {
                        grid.appendChild(child.cloneNode(true));
                    });

                    let isPaused = false;
                    let isDragging = false;
                    let startX, scrollLeft;
                    const speed = 0.5; // pixel per frame
                    
                    // Calculate the width of one set of items (approximate)
                    // We can't trust scrollWidth immediately if images aren't loaded, 
                    // but usually avatar images are small.
                    // Better logic: reset when scrollLeft >= scrollWidth / 3
                    
                    function autoScroll() {
                        if (!isPaused && !isDragging) {
                            grid.scrollLeft += speed;
                            
                            // Check reset condition
                            // We have 3 sets. If we scroll past the first set (1/3 total), snap back to 0.
                            // However, precise pixel math is better.
                            // Let's rely on scrollWidth.
                            if (grid.scrollLeft >= (grid.scrollWidth / 3)) {
                                grid.scrollLeft = 0; // or subtract, but 0 is safer for drift
                            }
                        }
                        requestAnimationFrame(autoScroll);
                    }
                    
                    // Mouse Drag Logic
                    grid.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        isPaused = true;
                        grid.style.cursor = 'grabbing';
                        startX = e.pageX - grid.offsetLeft;
                        scrollLeft = grid.scrollLeft;
                    });
                    
                   grid.addEventListener('mouseleave', () => {
                        isDragging = false;
                        isPaused = false;
                        grid.style.cursor = 'grab';
                    });
                    
                    grid.addEventListener('mouseup', () => {
                        isDragging = false;
                        isPaused = false;
                        grid.style.cursor = 'grab';
                    });
                    
                    grid.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        e.preventDefault();
                        const x = e.pageX - grid.offsetLeft;
                        const walk = (x - startX) * 2; // scroll-fast
                        grid.scrollLeft = scrollLeft - walk;
                    });

                    // Touch Logic
                    grid.addEventListener('touchstart', () => { isPaused = true; });
                    grid.addEventListener('touchend', () => { setTimeout(() => isPaused = false, 1000); });
                    
                    // Pause on Hover (optional, if user just wants to read)
                    grid.addEventListener('mouseenter', () => isPaused = true);

                    // Start loop
                    autoScroll();
                }

                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initAvatarScroll);
                } else {
                    initAvatarScroll();
                }
            })();
        </script>

		<!-- Back to Top Button -->
		<button id="back-to-top" onclick="scrollToTop()" title="Go to top">
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
				stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<path d="M18 15l-6-6-6 6"></path>
			</svg>
		</button>
		
		<!-- JavaScript -->
		<script>
			function selectName(name) {
				const nameInput = document.getElementById('name');
				nameInput.value = name;
				toggleClearButton();
				updateAvatarActive(name);
		
				// Manually trigger the input event on the input field itself
				htmx.trigger('#name', 'input');
		
				// Scroll to the top of the form for better UX
				const form = document.getElementById('name-form');
				if (form) {
					form.scrollIntoView({ behavior: 'smooth', block: 'start' });
				}
			}

			function updateAvatarActive(currentName) {
				const avatars = document.querySelectorAll('.avatar-premium');
				// Normalize: remove whitespace
				const clean = (str) => str ? str.trim().replace(/\s+/g, '') : '';
				const target = clean(currentName);
				
				avatars.forEach(avatar => {
					const dataName = clean(avatar.getAttribute('data-name'));
					
					// Compare normalized values
					if (dataName === target && dataName.length > 0) {
						avatar.classList.add('active');
					} else {
						avatar.classList.remove('active');
					}
				});
			}

			// Update active avatar and clear button state on load
			document.addEventListener('DOMContentLoaded', function() {
				const nameInput = document.getElementById('name');
				if (nameInput) {
					toggleClearButton();
					updateAvatarActive(nameInput.value);
					nameInput.addEventListener('input', function() {
						updateAvatarActive(this.value);
					});
				}
			});
		
			function toggleClearButton() {
				const nameInput = document.getElementById('name');
				const clearBtn = document.getElementById('clear-btn');
				if (nameInput && nameInput.value.length > 0) {
					clearBtn.style.display = 'block';
				} else if (clearBtn) {
					clearBtn.style.display = 'none';
				}
			}
		
			function clearName() {
				const nameInput = document.getElementById('name');
				nameInput.value = '';
				toggleClearButton();
				nameInput.focus();
				// Manually trigger the input event to clear the results via HTMX
				htmx.trigger('#name', 'input');
			}
		
			// Back to Top functionality
			const backToTopButton = document.getElementById("back-to-top");
		
			window.onscroll = function () {
				if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
					backToTopButton.style.display = "flex";
				} else {
					backToTopButton.style.display = "none";
				}
			};
		
			function scrollToTop() {
				window.scrollTo({ top: 0, behavior: 'smooth' });
			}
		
			document.addEventListener('DOMContentLoaded', function () {
				toggleClearButton();
				// Trigger initial load from the input field
				// htmx.trigger('#name', 'load'); // REMOVED: Managed by streaming
			});
		</script>
	}
}
